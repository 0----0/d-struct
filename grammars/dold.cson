# D Language grammar for Atom
#
# Props to http://www.regexr.com/ for helping me out with the regular
# expressions - really useful.
#
# Author: Jan Van Uytven

# For colors, as an example, Monokai defines the following.  It is probably
# likely that this are 'baseline' rules, as Monokai is one of the most
# popular styles
# .comment -> warm grey
# .string -> warm yellow
# .constant.numeric -> violet
# .constant.language -> violet
# .constant.character -> violet
# .constant.other -> violet
# .keyword -> coral
# .storage -> coral
# .storage.type -> blue italic
# .entity.name.class -> lime underline
# .entity.other.inherited-class -> lime italic underline
# .entity.name.function -> lime
# .entity.name.instance -> lt blue
# .variable.parameter -> orange italic
# .entity.name.tag -> coral
# .entity.other.attribute-name -> lime
# .support.function -> blue
# .support.type -> italic blue
# .support.class -> italic blue
# .invalid -> white on coral
# .invalid.deprecated -> white on purple
# .gfm.markup.heading -> bold lime
# .gfm.markup.underline -> warm yellow underline
# .gfm.markup.bold -> bold
# .gfm.markup.italic -> italic
# .gfm.markup.raw -> blue
# .gfm.markup.variable.list -> bold coral
# .gfm.markup.link -> lt grey
# .gfm.markup.link.entity -> violet
{
  'fileTypes' : [
    # 'd',
    # 'di'
  ],
  'name': 'Dold',
  'scopeName': 'source.d',

  # Root groups
  # comment
  #    line
  #        double-slash
  #    block
  #        documentation
  # constant
  #    numeric
  #    character
  #    language
  #    other
  # entity - a block within the document
  #    name
  #        function
  #        type
  #        tag
  #        section
  #    other
  #        inherited-class
  #        attribute-name
  # invalid
  #    illegal
  #    deprecated
  # keyword
  #    control
  #    operator
  #    other
  # markup
  #    underline
  #        link
  #    bold
  #    heading
  #    italic
  #    list
  #        numbered
  #        unnumbered
  #    quote
  #    raw
  #    other
  # meta - larger blocks, like a whole function name.  Not styled
  #    ???
  # punctuation - not described in Textmate, presumably an Atom addition?
  #    definition
  #    separator
  #    terminator
  # storage
  #    type
  #    modifier
  # string
  #    quoted
  #        single
  #        double
  #        triple
  #        other
  # support - items provided by the language/frameworkd, for example typeid() in D
  #    function
  #    class
  #    type
  #    constant
  #    variable
  #    other
  # variable
  #    parameter
  #    language
  #    other



  'patterns' : [
    {
      'include': '#package'
    },
    {
      'include': '#code'
    }
  ],
  # Repository of base constructs
  # Use these to match code patterns
  #
  # all-types
  # anonymous-classes-and-new
  # assertions
  # attributes
  # class
  # class-body
  # code
  # comments
  # comments-inline
  # constants-and-special-vars
  # enums
  # functions
  # keywords
  # method-call
  # methods
  # object-types
  # object-types-inherited
  # parameters
  # parens
  # primitive-types
  # storage-modifiers
  # strings
  # variables

  'repository': {
    'all-types': {
      'patterns': [
        {
          'include': '#class'
        },
        {
          'include': '#enum'
        },
        {
          'include': '#primitive-types'
        },
        {
          'include': '#struct'
        },
        {
          'include': '#union'
        }
      ],
    },
    'all-values': {
      'patterns': [
        {
          'include': '#numerics'
        },
        {
          'include': '#strings'
        },
        {
          'include': '#constants-and-special-vars'
        },
        # {
        #   'include': '#variables'
        # }
      ]
    },
    'anonymous-classes-and-new': {
     'patterns': [],
    },
    'asm': {
      'patterns': [
        { # single-line asm
          'match': '(asm)\\s+([^\\{\\}$]+)',
          'captures': {
            '1': { 'name': 'keyword.other.asm.d' },
            '2': { 'name': 'gfm.markup.raw.asm.d' }
          }
        },
        { # block-level asm
          'begin': '(asm)(?:\\s+{)',
          'beginCaptures': {
            '1': { 'name': 'keyword.other.asm.d' }
          },
          'end': '}',
          'contentName': 'gfm.markup.raw.asm.d'
        }
      ]
    },
    'assertions': {
      # assert, enforce, exceptions and other contract structures
      'patterns': [
        { # Exception keywords
          'match': '\\b(try|catch|finally|throw|nothrow|in|body)\\b',
          'name': 'keyword.other.exception.d'
        },
        { # assertions
          'match': '\\b(assert|enforce|invariant)',
          'name': 'entity.name.function.assertion.d'
        }
     ]
    },
    'attributes': {
      'patterns': [
        {
          'match': '(@(safe|system|trusted|property))\\b',
          'name': 'keyword.other.safety.d'
        }
      ]
    },
    'block': {
      # meta-pattern - any legal code that can exist inside { }
      'begin': '{',
      'end': '}',
      'patterns': [
        {
          'include': '#block-code'
        }
      ]
    },
    'block-code': {
      # Meta class - basically all legal code that can be in a block
      'patterns': [
        {
          'include': '#functions'
        },
        {
          'include': '#assertions'
        },
        {
          'include': '#strings'
        },
        {
          'include': '#comments'
        },
        {
          'include': '#primitive-types'
        },
        {
          'include': '#constants-and-special-vars'
        },
        {
          'include': '#attributes'
        },
        {
          'include': '#keywords'
        },
        {
          'include': '#storage-modifiers'
        },
        {
          'include': '#block-markup'
        },
        {
          'include': '#variables'
        },
        {
          'include': '#methods'
        }
      ]
    },
    'class': {
      'patterns': []
    },
    'class-body': {
      'patterns': []
    },
    'code': {
      # Everything that's not a package, script header, module or import
      'patterns': [
        {
          'include': '#all-types'
        },
        {
          'include': '#all-values'
        },
        {
          'include': '#asm'
        },
        {
          'include': '#comments'
        },
        {
          'include': '#keywords'
        }

      ]
    },
    'comments': {
     'patterns': [
        {
          'match': '/\\*\\*/',
          'name': 'comment.block.empty.d'
        },
        {
          'include': '#comments-inline'
        }
      ]
    },
    'comments-inline': {
      'patterns': [
        { # C-style comments
          'begin': '/\\*',
          'end': '\\*/',
          'name': 'comment.block.d'
        },
        { # C++-style comments
          'begin': '//',
          'end': '$',
          'name': 'comment.block.d'
        },
        {
          # Embedded documentation style
          'begin': '/\\+\\+',
          'end': '\\+/',
          'name': 'comment.block.embedded.d'
        }
      ]
    },
    'constants-and-special-vars': {
      'patterns': [
        { # Special constants
          'match': '\\b(true|false|null)\\b',
          'name': 'constant.language.d'
        },
        { # Special variables
          'match': '\\b(this|super)\\b',
          'name': 'variable.language.d'
        },
        {
          'include': '#numerics'
        }
      ]
    },
    'enums': {
      'patterns': []
    },
    'functions': {
      # Base functions
      'patterns': [
        {
          "begin": "\\b(function\\*?)"
        }
      ],
    },
    'keywords': {
      'patterns': [
        { # Control keywords
          'match': '\\b(case|continue|default|do|else|for|foreach|goto|if|return|switch|while)\\b',
          'name': 'keyword.control.d'
        },
        { # ternary keywords
          'match': '\\?|:',
          'name': 'keyword.control.ternary.d'
        },
        { # Type operators
          'match': '(\\b(typeid|typeof|is|!is)\\b)',
          'name': 'keyword.operator.d'
        },
        { # Bitwise operators & comparison
          'match': '(<<|>>>?|~|\\^|\\||&)',
          'name': 'keyword.operator.bitwise.d'
        },
        { # Bitwise assignment
          'match': '((&|\\^|\\||<<|>>>?)=)',
          'name': 'keyword.operator.assignment.bitwise.d'
        },
        { # Comparison operators
          'match': '(==|!=|<=|>=|<|>)',
          'name': 'keyword.operator.comparison.d'
        },
        { # Slice and array-specific operators
          'match': '(\\bin\\b)',
          'name': 'keyword.operator.array.d'
        },
        { # Arithmetic & concatenation
          'match': '(\\-|\\+|\\*|\\/|%|\\^\\^|~)',
          'name': 'keyword.operator.arithmetic.d'
        },
        { # Assignment
          'match': '([+*/%-~]?=)',
          'name': 'keyword.operator.assignment.d'
        },
        { # logical operators
          'match': '(!|&&|\\|\\|)',
          'name': 'keyword.operator.logical.d'
        },
        { # dereferencing, method refers, etc..
          'match': '',
          'name': 'keyword.operator.dereference.d'
        },
        { # statement terminator (semicolon)
          'match': ';',
          'name': 'punctuation.terminator.d'
        },
        { # alias
          'match': '(alias)\\s+(.+)\\s+(.+);',
          'captures': {
            '1': { 'name': 'keyword.other.alias.d' },
            '2': { 'name': 'variable.parameter.alias.d' },
            '3': { 'name': 'variable.parameter.alias.d' }
          }
        }
      ]
    },
    'method-call': {
      'patterns': []
    },
    'methods': {
      'patterns': [
        {
          'match': '([a-zA-Z_][a-zA-Z0-9_]*)(\\.[a-zA-Z_][a-zA-Z0-9]+)+',
          'captures': {
            '1': { 'name': 'entity.name.class.called.d' },
            '2': { 'name': 'entity.name.function.method.d' }
          }
        }
      ]
    },
    'numerics': {
      # Match all numerics D is capable of (a lot!)
      'patterns': [
        { # Handle the weirdness that is hexadecimal floats
          'match': '0[xX][0-9a-fA-F_]*(\\.[0-9a-fA-F_]*)?([pP]|([pP][\+-]))[0-9][0-9_]*[LfF]?',
          'name': 'constant.numeric.float.hexidecimal.d'
        },
        { # Normal floats
          'match': '(((0[1-9_])|[1-9])?[0-9_]*\\.[0-9_]*([eE][\+-]?)?[0-9][0-9_]*[lfF]?)',
          'name': 'constant.numeric.float.d'
        },
        { # Hex, binary and octal integers
          'match': '0(((x|X)[0-9a-fA-F_]+)|([0-7_]+)|(b|B)[01_]+)([lL][uU]|[uU][lL]|[uUlL])?',
          'name': 'constant.numeric.integer.other.d'
        },
        { # base-10 integers
          'match': '[1-9][0-9_]*([lL][uU]|[uU][lL]|[uUlL])?',
          'name': 'constant.numeric.integer.decimal.d'
        }
      ]
    },
    'object-types': {
      'patterns': []
    },
    'object-types-inherited': {
      'patterns': []
    },
    'package': {
      # Module-level imports, module decls and package decls
      'patterns': [
        { # import packages
          'match': '\\b(import|module)\\s+(.+);',
          'captures': {
            '1': { 'name': 'keyword.other.import.d' },
            '2': { 'name': 'support.class.import.d' }
          }
        },
        { # rdmd script
          'match': '^\\s*(#!.+)',
          'name': 'gfm.markup.heading.script.d'
        }
      ]
    },
    'parameters': {
      # tag generic function and methos parameters
      'patterns': [
        {
          'begin': '(?![\\s,)])',
          'end': '(?=[,)])',
          'patterns': [
            {
              'match': '\\G[_a-zA-Z][_a-zA-Z0-9]*',
              'name': 'variable.parameter.function.d'
            },
            {
              'include': '$self'
            }
          ]
        }
      ]
    },
    'parens': {
      # meta-pattern
      'patterns': [
        'begin': '\\(',
        'end': '\\)',
        'patterns': [
          {
            'include': '#code'
          }
        ]
      ]
    },
    'primitive-types': {
      'patterns': [
        {
          'match': '\\b((void|bool|byte|ubyte|short|ushort|int|uint|long|ulong|float|double|real|char|wchar|dchar|size_t|string|wstring|dstring|T|T1|T2|T3|V|R|E|S|U)(\\*{0,3})((\\[\\])*)(\\()?)\\s',
          'captures': {
            '1': { 'name': 'storage.type.primitive.array.d' },
          }
        }
      ]
    },
    'storage-modifiers': {
      'patterns': [
        {
          'match': '\\b(?:align|auto|const|export|extern|in|inout|out|pure|ref|static)\\b',
          'name': 'storage.modifier.data.d'
        }
      ]
    },
    'strings': {
      'patterns': [
        {
          'begin': '"',
          'beginCaptures': {
            '0': { 'name': 'punctuation.definition.string.begin.d' }
          },
          'end': '"',
          'endCaptures': {
            '0': { 'name': 'punctuation.definition.string.end.d' },
          }
          'name': 'string.quoted.double.d',
          # Deal with escape characters
          'patterns': [
            {
              'match': '\\\\.',
              'name': 'constant.character.escape.d'
            }
          ]
        }
      ]
    },
    'variables': {
      'patterns': [
        {
          'match': '\\s+([a-zA-Z_][A-Za-z0-9_]+)\\b',
          'captures': {
            1: { 'name': 'invalid.deprecated.d' }
          }
        }
      ]
    }
  # Repository end
  }
  # End of d.cson
}
